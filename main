import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int PNo ; // number of partitions 
        char strategy; // F for First Fit, B for Best Fit, W for Worst Fit , CASE INSENSETIE 
        int PSize ; // size of each partition used later in memory creation loop
        int limit=0 ; // to specify end adress and start adress , it is the limit of the previous partition thus the base for the current 
        int lastProcid = 0 ; // whenever user allocates a new process then its id shall be "P"+(++lastProcid) IN ALLOCATE METHOD
       

        
        // Read PNo from the user
        System.out.print("Enter the number of partitions in the memory: ");
        this.PNo = scanner.nextInt();

        // create memory 
        Partition[] Memory = new Partition[this.PNo] ;

        // get user input of each partition 
        System.out.print("Now you will enter each partitions size in KB : ");

        
        for (int i = 0 ; i<Memory.size ; i++){
            System.out.print("Enter size of partition "+(i+1)+"in KB :");
            PSize=scanner.nextInt();
            int currentbase = limit ; // start adrs
            int currentLimit=limit+this.PSize-1; // end adrs 
            this.Partition[i]= new Partition(this.PSize,currentbase,currentLimit);
            this.limit=currentLimit ; 

        }

        // allocation strategy display a menu(only once) asking  user to choose the algorithm then allocate accordingly 
        boolean choosen = false ; 
         while (!choosen) {
            System.out.print("Please choose an allocation strategy (F for First Fit, B for Best Fit, W for Worst Fit): ");
            strategy = scanner.nextLine().toUpperCase().charAt(0);


            if ( this.strategy=='F' || this.strategy=='W' || this.strategy=='B')
            choosen = true ; 
            else
            System.out.print("Invalid input ");

        } 

        // Displaying the menu 
        do {
            System.out.println("----- Memory Manager Menu -----");
            System.out.println("1. Allocate Memory");
            System.out.println("2. Deallocate Memory");
            System.out.println("3. Generate Report and Write to File");
            System.out.println("4. Exit Program");
            System.out.print("Enter your choice: ");
            choice = scanner.nextInt();

            switch (choice) {
                case 1:
                    allocateMemory();
                    break;
                case 2:
                    deallocateMemory();
                    break;
                case 3:
                    generateReport();
                    break;
                case 4:
                    System.out.println("Exiting the program...");
                    break;
                default:
                    System.out.println("Invalid choice. Please try again.");
            }
            System.out.println();
        } while (choice != 4);

        
    }

    private static void allocateMemory() {

       if(ISfull())
       return;

        System.out.println("Enter Size of the process to allocate");
        int processSize= scanner.nextInt();
        String processId = "P"+(++this.lastProcid)+"";

        
        int bestLOC=-1;
        int worstLOC=-1;
        int sizeBEST=-1; //min
        int sizeWORST=-1; //max

        boolean noFIT=true; // To check if there is block where process size < partition size

        switch (strategy) {
            case 'F': //firstfit
               for(int i=0; i<Memory.length; i++ )
                if(Memory[i].getStatus()== Status.free && Memory[i].getPartitionSize()>= processSize){
                    Memory[i].setInFragSize((Memory[i].getPartitionSize()-processSize));
                    Memory[i].setStatus(Status.allocated);
                    Memory[i].setProcId(processId);
                    noFIT=false;
                    break;
                }
                break;

            case 'B'://bestfit
            for(int i=0; i<Memory.length; i++ )
                if(Memory[i].getStatus()== Status.free && Memory[i].getPartitionSize()>= processSize){

                    if(bestLOC<0){ //first block fit
                        bestLOC= i;
                        sizeBEST= Memory[i].getPartitionSize();
                    }

                    if(bestLOC >=0 && Memory[i].getPartitionSize()<sizeBEST){
                        bestLOC= i;
                        sizeBEST= Memory[i].getPartitionSize();
                    }
                }

               // allocate
               if(bestLOC >=0){// memory not full
               Memory[bestLOC].setInFragSize((Memory[bestLOC].getPartitionSize()-processSize));
               Memory[bestLOC].setStatus(Status.allocated);
               Memory[bestLOC].setProcId(processId);
               noFIT=false;
               }
                break;

            case 'W': //worstfit
            for(int i=0; i<Memory.length; i++ )
                if(Memory[i].getStatus()== Status.free && Memory[i].getPartitionSize()>= processSize){

                    if(worstLOC<0){ //first block fit
                        worstLOC= i;
                        sizeWORST= Memory[i].getPartitionSize();
                    }

                    if(worstLOC >=0 && Memory[i].getPartitionSize()>sizeWORST){
                        worstLOC= i;
                        sizeWORST= Memory[i].getPartitionSize();
                    }
                }

               // allocate
               if(worstLOC >=0){
               Memory[worstLOC].setInFragSize((Memory[worstLOC].getPartitionSize()-processSize));
               Memory[worstLOC].setStatus(Status.allocated);
               Memory[worstLOC].setProcId(processId);
               noFIT=false;
            }
            break;

            default:
                System.out.println("There is no strategy chosen.");
        }
        
        if(noFIT)
        System.out.println("There is no block in memory fit "+processId+".");
        // anood and whoever resposible for this method veery important dont foget to check that there is enough memory space if not display an error msg 
        // also when allocating dont forget to set the procId to the partition and internalfragmentsize=partitionSize-process size also set status to "allocated"
        // display memory after allocation in this format [P6 | H | P9 | P7 ] by method printMemory()
        printMemory();
        // exeptions : memory is full , process size > partition size , process already allocated

    }
    private static boolean ISfull(){
        boolean full=true;
        for(int i=0; i<Memory.length; i++ ){
        if(Memory[i].getStatus()== Status.free)
        full=false;
    }
    if(full){
    System.out.println("Memory is full.");
    return true;}
    else 
    return false;
}

private static void printMemory(){
    String str="";
    str=str+"[ ";
    for(int i=0; i<Memory.length; i++ ){
        if(Memory[i].getStatus()== Status.free)
        str=str+"H | ";
        else
        str=str+Memory[i].getProcId()+" | ";
}
int x=str.lastIndexOf('|');
String str1= str.substring(0,x);
str1=str1+"]";
System.out.println("Memory display: ");
System.out.println(str1);
}

    private static void deallocateMemory() {




        boolean isEmpty = true;

          for(int i ; i <Memory.length ; i++){
          
          if (Memory[i]!=null){
        isEmpty=false;
        break;

          }
          
          }


          if (isEmpty) {
            System.out.println("The memory is empty.");
            break; 
        }

        boolean found = false ; 

            while ( !found )   {   

            System.out.println("Enter the process ID: ");
            String procId = scanner.nextLine();
        

            for(int i ; i <Memory.length ; i++){

                if(Memory[i].getProcId=procId){

                   Memory[i].setStatus=Status.free ;
                   
                   Memory[i].setInFragSize=-1; 
                   Memory[i].setProcId=null ;

                     System.out.println("Process ID;"+procId+" Successfully deallocateded");
                    found=true ; 

                }
      


            } // looped over all memory 

            if ( found == false )
            System.out.println("Process ID :"+procId+" Not found");


        }
        
         


        // first loop over memory to check that it is not empty 
        //if not ask user to enter process id 
        // loop to find the desired partittion
        // set the following status=free , inFragSize=-1 , procId=null ;  
        //display sucess msg
    }


    private static void generateReport() {

        //write into file 
        try {
            FileWriter writer = new FileWriter("Report.txt");
            writer.write("\n");
            writer.write("\n");
            writer.write("\n");
            writer.close();
            System.out.println("Memory report generated and written to 'Report.txt'.");
        } catch (IOException e) {
            System.out.println("Error occurred while writing to the file.");
        }

        //display on console 
        System.out.println("-----------------------------------------------------------");
        System.out.println("Memory Information");
        for (int i = 0 ; i<Memory.size ; i++){
            System.out.println("partition"+(i++)+""); 

            System.out.println(partition.toString());
            System.out.println("-----------------------------------------------------------");

        }

    }// end main
} 